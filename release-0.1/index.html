<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TextParse.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>TextParse.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Reading-CSV-1">Reading CSV</a></li><li><a class="toctext" href="#Extensible-parsing-framework-1">Extensible parsing framework</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="TextParse-1" href="#TextParse-1">TextParse</a></h1><p>TextParse uses Julia&#39;s generated functions to generate efficient specialized parsers for text files. TextParse minimizes allocations and hence avoids involving the GC.</p><ul><li><a href="index.html#TextParse-1">TextParse</a></li><ul><li><a href="index.html#Installation-1">Installation</a></li><li><a href="index.html#Reading-CSV-1">Reading CSV</a></li><li><a href="index.html#Extensible-parsing-framework-1">Extensible parsing framework</a></li></ul></ul><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><pre><code class="language-none">Pkg.clone(&quot;https://github.com/JuliaComputing/TextParse.jl.git&quot;)</code></pre><h2><a class="nav-anchor" id="Reading-CSV-1" href="#Reading-CSV-1">Reading CSV</a></h2><p>The most useful API is probably <code>csvread</code> - read a CSV file:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.csvread" href="#TextParse.csvread"><code>TextParse.csvread</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">csvread(file::Union{String,IO}, delim=&#39;,&#39;; &lt;arguments&gt;...)</code></pre><p>Read CSV from <code>file</code>. Returns a tuple of 2 elements:</p><ol><li><p>A tuple of columns each either a <code>Vector</code>, <code>NullableArray</code> or <code>PooledArray</code></p></li><li><p>column names if <code>header_exists=true</code>, empty array otherwise</p></li></ol><p><strong>Arguments:</strong></p><ul><li><p><code>file</code>: either an IO object or file name string</p></li><li><p><code>delim</code>: the delimiter character</p></li><li><p><code>quotechar</code>: character used to quote strings, defaults to <code>&quot;</code></p></li><li><p><code>escapechar</code>: character used to escape quotechar in strings. (could be the same as quotechar)</p></li><li><p><code>pooledstrings</code>: whether to try and create PooledArray of strings</p></li><li><p><code>nrows</code>: number of rows in the file. Defaults to <code>0</code> in which case we try to estimate this.</p></li><li><p><code>header_exists</code>: boolean specifying whether CSV file contains a header</p></li><li><p><code>colnames</code>: manually specified column names. Could be a vector or a dictionary from Int index (the column) to String column name.</p></li><li><p><code>colparsers</code>: Parsers to use for specified columns. This can be a vector or a dictionary from column name / column index (Int) to a &quot;parser&quot;. The simplest parser is a type such as Int, Float64. It can also be a <code>dateformat&quot;...&quot;</code>, see <a href="@ref">CustomParser</a> if you want to plug in custom parsing behavior</p></li><li><p><code>type_detect_rows</code>: number of rows to use to infer the initial <code>colparsers</code> defaults to 20.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/src/csv.jl#L36-L55">source</a><br/></section><p>Some notable features of the CSV parser are:</p><ul><li><p>CSV parsing kernel generated by TextParse is type-inferable.</p></li><li><p>Uses PooledArrays for strings by default, promoting to an <code>Array</code> only if number of unique elements goes over 5% (after 400 rows have been read).</p></li><li><p>Avoids allocating the string in PooledArray unless the string is not in the pool</p></li><li><p>Doesn&#39;t assume all columns are nullable by default, switches column to <code>NullableArray</code> if an NA value is found</p></li><li><p>Flexible about predicted column types, can convert the column mid-way if the type changes and switch to a new fast generated method</p></li><li><p>Fast date time parsing even on Julia 0.5</p></li></ul><h2><a class="nav-anchor" id="Extensible-parsing-framework-1" href="#Extensible-parsing-framework-1">Extensible parsing framework</a></h2><p>TextParse operates by defining small parsers which are specialized to parse one kind of text very efficiently. Each such parser is described by a subtype of <code>AbstractToken{T}</code>. An <code>AbstractToken{T}</code> type should implement a <code>tryparsenext</code> method:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Dates.tryparsenext" href="#Base.Dates.tryparsenext"><code>Base.Dates.tryparsenext</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>tryparsenext{T}(tok::AbstractToken{T}, str, i, till, localopts)</code></p><p>Parses the string <code>str</code> starting at position <code>i</code> and ending at or before position <code>till</code>. <code>localopts</code> is a <a href="index.html#LocalOpts-1">LocalOpts</a> object which contains contextual options for quoting and NA parsing. (see <a href="index.html#LocalOpts-1">LocalOpts</a> documentation)</p><p><code>tryparsenext</code> returns a tuple <code>(result, nextpos)</code> where <code>result</code> is of type <code>Nullable{T}</code>, null if parsing failed, non-null containing the parsed value if it succeeded. If parsing succeeded, <code>nextpos</code> is the position the next token, if any, starts at. If parsing failed, <code>nextpos</code> is the position at which the parsing failed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/src/field.jl#L12-L18">source</a><br/></section><h3><a class="nav-anchor" id="Available-AbstractToken-types-1" href="#Available-AbstractToken-types-1">Available AbstractToken types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.Numeric" href="#TextParse.Numeric"><code>TextParse.Numeric</code></a> — <span class="docstring-category">Type</span>.</div><div><p>parse numbers of type T</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/src/field.jl#L95-L97">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.StringToken" href="#TextParse.StringToken"><code>TextParse.StringToken</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Parses string to the AbstractString type <code>T</code>. If <code>T</code> is <code>StrRange</code> returns a <code>StrRange</code> with start position (<code>offset</code>) and <code>length</code> of the substring. It is used internally by <code>csvparse</code> for avoiding allocating strings.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/src/field.jl#L160-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.DateTimeToken" href="#TextParse.DateTimeToken"><code>TextParse.DateTimeToken</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DateTimeToken(T, fmt::DateFormat)</code></pre><p>Parse a date time string of format <code>fmt</code> into type <code>T</code> which is either <code>Date</code>, <code>Time</code> or <code>DateTime</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/src/field.jl#L357-L362">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.NAToken" href="#TextParse.NAToken"><code>TextParse.NAToken</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>NAToken(inner::AbstractToken; options...)</code></p><p>Parses a Nullable item.</p><p><strong>Arguments</strong></p><ul><li><p><code>inner</code>: the token to parse if non-null.</p></li><li><p><code>emptyisna</code>: should an empty item be considered NA? defaults to true</p></li><li><p><code>nastrings</code>: strings that are to be considered NA. Defaults to <code>String[&quot;#N/A&quot;, &quot;#N/A N/A&quot;, &quot;#NA&quot;, &quot;#n/a&quot;, &quot;#n/a n/a&quot;, &quot;#na&quot;, &quot;-1.#IND&quot;, &quot;-1.#QNAN&quot;, &quot;-1.#ind&quot;, &quot;-1.#qnan&quot;, &quot;-NaN&quot;, &quot;-nan&quot;, &quot;-nan&quot;, &quot;-nan&quot;, &quot;1.#IND&quot;, &quot;1.#QNAN&quot;, &quot;1.#ind&quot;, &quot;1.#qnan&quot;, &quot;N/A&quot;, &quot;N/A&quot;, &quot;NA&quot;, &quot;NA&quot;, &quot;NULL&quot;, &quot;NaN&quot;, &quot;n/a&quot;, &quot;n/a&quot;, &quot;na&quot;, &quot;na&quot;, &quot;nan&quot;, &quot;nan&quot;, &quot;nan&quot;, &quot;null&quot;]</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/src/field.jl#L402-L411">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.Quoted" href="#TextParse.Quoted"><code>TextParse.Quoted</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>Quoted(inner::AbstractToken; &lt;kwargs&gt;...)</code></p><p><strong>Arguments:</strong></p><ul><li><p><code>inner</code>: The token inside quotes to parse</p></li><li><p><code>required</code>: are quotes required for parsing to succeed? defaults to <code>false</code></p></li><li><p><code>includequotes</code>: include the quotes in the output. Defaults to <code>false</code></p></li><li><p><code>includenewlines</code>: include newlines that appear within quotes. Defaults to <code>true</code></p></li><li><p><code>quotechar</code>: character to use to quote (default decided by <code>LocalOpts</code>)</p></li><li><p><code>escapechar</code>: character that escapes the quote char (default set by <code>LocalOpts</code>)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/src/field.jl#L277-L287">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.CustomParser" href="#TextParse.CustomParser"><code>TextParse.CustomParser</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CustomParser(f, T)</code></pre><p>Provide a custom parsing mechanism.</p><p><strong>Arguments:</strong></p><ul><li><p><code>f</code>: the parser function</p></li><li><p><code>T</code>: The type of the parsed value</p></li></ul><p>The parser function must take the following arguments:</p><ul><li><p><code>str</code>: the entire string being parsed</p></li><li><p><code>pos</code>: the position in the string at which to start parsing</p></li><li><p><code>len</code>: the length of the string the maximum position where to parse till</p></li><li><p><code>opts</code>: a <a href="index.html#LocalOpts-1">LocalOpts</a> object with options local to the current field.</p></li></ul><p>The parser function must return a tuple of two values:</p><ul><li><p><code>result</code>: A <code>Nullable{T}</code>. Set to null if parsing must fail, containing the value otherwise.</p></li><li><p><code>nextpos</code>: If parsing succeeded this must be the next position after parsing finished, if it failed this must be the position at which parsing failed.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/src/field.jl#L64-L84">source</a><br/></section><h3><a class="nav-anchor" id="LocalOpts-1" href="#LocalOpts-1">LocalOpts</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TextParse.LocalOpts" href="#TextParse.LocalOpts"><code>TextParse.LocalOpts</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LocalOpts</code></pre><p>Options local to the token currently being parsed.</p><ul><li><p><code>endchar</code>: Till where to parse. (e.g. delimiter or quote ending character)</p></li><li><p><code>quotechar</code>: the quote character</p></li><li><p><code>escapechar</code>: char that escapes the quote</p></li><li><p><code>includequotes</code>: whether to include quotes while parsing</p></li><li><p><code>includenewlines</code>: whether to include newlines while parsing</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/TextParse.jl/tree/44a36131a6a592f612ea65c0bac009612a3cc112/src/field.jl#L23-L32">source</a><br/></section><footer><hr/></footer></article></body></html>
